import { Injectable, InternalServerErrorException, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import * as path from 'path';
import * as fs from 'fs';
import { Response } from 'express';
import type { Multer } from 'multer';
import { Document } from './entities/document.entity';
import { CreateDocumentDto } from './dto/create-document.dto';
import { UpdateDocumentDto } from './dto/update-document.dto';

@Injectable()
export class DocumentService {
  private readonly ALLOWED_MIME_TYPES = [
    // Images
    'image/jpeg',
    'image/png',
    // PDF
    'application/pdf',
    // Word documents
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    // Excel
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  ];

  constructor(
    @InjectModel(Document)
    private documentModel: typeof Document,
  ) {}

  async create(
    createDocumentDto: CreateDocumentDto,
    file?: Multer.File,
  ): Promise<Document> {
    try {
      if (!file) {
        throw new BadRequestException('No file provided');
      }

      if (!this.ALLOWED_MIME_TYPES.includes(file.mimetype)) {
        // Delete the uploaded file if MIME type is not allowed
        const filePath = path.join(process.cwd(), 'uploads', 'documents', file.filename);
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
        }
        throw new BadRequestException(
          `File type not allowed. Allowed types: images (JPEG, PNG), PDF, Word documents, and Excel files`,
        );
      }

      // Use the filename generated by multer storage
      const fileName = file.filename;
      const fileUrl = `/uploads/documents/${fileName}`;
      const fileSize = file.size;
      const fileType = file.mimetype;

      return await this.documentModel.create({
        subCategoryId: createDocumentDto.subCategoryId,
        userId: createDocumentDto.userId,
        documentTitle: createDocumentDto.documentTitle,
        fileName: fileName,
        fileUrl: fileUrl,
        fileSize: fileSize,
        fileType: fileType,
        versionNumber: createDocumentDto.versionNumber ?? 1,
      });
    } catch (error) {
      if (error.name === 'SequelizeUniqueConstraintError') {
        throw new InternalServerErrorException(
          'Document with this name already exists',
        );
      }
      throw error;
    }
  }

  async findAll(): Promise<Document[]> {
    return await this.documentModel.findAll({
      include: ['subCategory', 'user'],
    });
  }

  async findOne(id: number): Promise<Document> {
    const document = await this.documentModel.findByPk(id, {
      include: ['subCategory', 'user'],
    });
    if (!document) {
      throw new NotFoundException(`Document with ID ${id} not found`);
    }
    return document;
  }

  async findBySubCategory(subCategoryId: number): Promise<Document[]> {
    return await this.documentModel.findAll({
      where: { subCategoryId },
      include: ['subCategory', 'user'],
    });
  }

  async findByUser(userId: number): Promise<Document[]> {
    return await this.documentModel.findAll({
      where: { userId },
      include: ['subCategory', 'user'],
    });
  }

  async update(
    id: number,
    updateDocumentDto: UpdateDocumentDto,
  ): Promise<Document> {
    const document = await this.findOne(id);
    await document.update(updateDocumentDto as any);
    return document;
  }

  async editMetadata(
    id: number,
    updateDocumentDto: UpdateDocumentDto,
  ): Promise<Document> {
    const document = await this.findOne(id);
    
    // Only allow editing metadata fields, not file-related fields
    const allowedFields = ['documentTitle', 'subCategoryId'];
    const updateData: any = {};
    
    for (const field of allowedFields) {
      if (field in updateDocumentDto) {
        updateData[field] = updateDocumentDto[field];
      }
    }
    
    if (Object.keys(updateData).length === 0) {
      throw new BadRequestException(
        'No valid metadata fields to update. Allowed fields: documentTitle, subCategoryId',
      );
    }
    
    await document.update(updateData);
    return document;
  }

  async download(id: number, res: Response): Promise<void> {
    const document = await this.findOne(id);
    
    // Construct file path
    const fileName = document.fileName;
    const filePath = path.join(process.cwd(), 'uploads', 'documents', fileName);
    
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      throw new NotFoundException(
        `Document file not found: ${fileName}`,
      );
    }
    
    // Set response headers
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="${document.documentTitle}"`,
    );
    res.setHeader('Content-Type', document.fileType);
    res.setHeader('Content-Length', document.fileSize);
    
    // Stream file to response
    const fileStream = fs.createReadStream(filePath);
    fileStream.pipe(res);
  }

  async remove(id: number): Promise<void> {
    const document = await this.findOne(id);
    
    // Delete the physical file
    const fileName = document.fileName;
    const filePath = path.join(process.cwd(), 'uploads', 'documents', fileName);
    
    if (fs.existsSync(filePath)) {
      try {
        fs.unlinkSync(filePath);
      } catch (error) {
        console.error(`Failed to delete file: ${filePath}`, error);
        // Continue with database deletion even if file deletion fails
      }
    }
    
    await document.destroy();
  }

  async incrementVersion(id: number): Promise<Document> {
    const document = await this.findOne(id);
    await document.increment('versionNumber');
    return document;
  }
}
